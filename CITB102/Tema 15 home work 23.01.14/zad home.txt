Домашна работа 3 (с оценяване)

Това е третата домашна работа с оценка за Текущ Контрол. Отново има 4-ри комплекта, като всеки студент трябва да реши номера, който съвпада с остатъка от деление на факултетния му номер с 4 плюс 1. Например, ако факултетния номер е F12345, то 12345 по модул от 4 (12345 % 4) е 1, плюс 1 е 2, т.е. студентът трябва да реши комплект 2. Студент с номер 12344 ще решава комплект 0+1 = 1.

ВАЖНО: Има нов регламент за предаване на домашните (и контролните). В същата тема като заданието ще намерите заготовки за решенията, които включват 3 файла с разширение cpp, където трябва да поместите вашите решения, 3 файла .in, които представляват примерен вход за всяка задача и 3 файла .out, които са правилния изход за примерния вход. Може да проверите дали програмите ви работят коректно като ги пуснете срещу примерния вход и сравните резулата с .out файловете.

Вашите решения трябва да са поместени съответно в трите cpp файла. Всеки файл има header - коментар в C++, който изглежда по следния начин:

/***
FN:F00000
PID:1
GID:1
*/

Моля, не го изтривайте. Единственото, което трябва да направите, е да запишете вашият факултетен номер на мястото на "F00000", т.е. ако вашият факутетен номер е 12345, то след промяната хедърът ще изглежда по следния начин:

/***
FN:F12345
PID:1
GID:1
*/

Спазването на формата на входа и изхода показан в примерите към всяка задача е задължително за пълния брой точки.

Комплект 1.

1. Напишете програма, която изчислява щастливо прозведение на два вектора - A и B. Щастливо произведение е: A[0]*B[0] + A[1]*B[1] + A[2]*B[2] + ... + A[n-1]*B[n-1]. 
Програмата трябва да чете от стандартния вход едно число N - броя на елементите на векторите. Следват N на на брой числа - тези на първия вектор, след което още N числа - тези на втория.
Реализирайте програмата с функция, която приема 2 вектора и връща double.

Пр. 
Вход:
3
1 2 3
4 5 6
Изход:
32

2. Напишете програма, която може да преобръща вектор. Програмата трябва да чете до края на входа елементите на вектора.
Реализирайте програмата с функция, която приема вектора по референция и не връща стойност. След изпълнението на функцията трябва подадения вектор е преобърнат на опаки и да се изпечата на стандартния изход. Не може да ползвате готови функции за обръщане на вектор, т.е. трябва вие да имплементирате тази логика сами.

Пр.
Вход:
1 2 3
Изход:
3 2 1

3. Напишете интерактивна програма, която ще манипулира един вектор. Тя трябва да чете от стандартния вход едно число N - броя на елементите на вектора и N на брой числа - елементите на вектора. 
След което започва да чете и изпълнява операции с прочетения вектор. Програмата трябва да изпълнява следните операции:
a) add 2 -4 - добавя числото -4 на позиция 2 във вектора (може да разчитате, че позициите ще бъдат в обсега на вектора)
б) remove 2 - премахва числото на позиция 2 във вектора (може да разчитате, че позициите ще бъдат в обсега на вектора)
в) shift_left - измествате циклично всички елементи с 1 позиция на ляво като използвате функция и подадете вектора по референция. Примерно, ако числата във вектора са "1, 2, 3", след операцията числата във вектора ще бъдат: "2, 3, 1"
г) shift_right - измествате циклично всички елементи с 1 позиция на дясно като използвате функция и подадете вектора по референция. Примерно, ако числата във вектора са "1, 2, 3", след операцията числата във вектора ще бъдат: "3, 1, 2"
д) print - изпечатва текущото състояние на елементите на вектора
е) exit - прекъсва изпълнението на програмата

Комплект 2.

1. Напишете програма, която изчислява щастливо прозведение на два вектора - A и B. Щастливо произведение е: A[0]*B[0] - A[1]*B[1] - A[2]*B[2] - ... - A[n-1]*B[n-1]. 
Програмата трябва да чете от стандартния вход едно число N - броя на елементите на векторите. Следват N на на брой числа - тези на първия вектор, след което още N числа - тези на втория.
Реализирайте програмата с функция, която приема 2 вектора и връща double.

Пр. 
Вход:
3
1 2 -3
4 -5 -6
Изход:
4

2. Напишете програма, която може да измества циклично вектор на дясно. Програмата трябва да чете до края на входа елементите на вектора.
Реализирайте програмата с функция, която приема вектора по референция и не връща стойност. След изпълнението на функцията подадения вектор трябва да е изместен циклично на дясно - a[0]->a[1], a[1]->a[2], ..., a[n-1]->a[0].

Пр.
Вход:
1 2 3
Изход:
3 1 2

3. Напишете интерактивна програма, която ще манипулира 1 вектор. Тя трябва да прочита от стандартния вход 1 число N - броя на елементите на вектора и N на на брой числа - тези на вектора. 
След което започва да чете и изпълнява операции с прочетения вектор. Програмата трябва да изпълнява следните операции:
a) add 2 -4 - добавя числото -4 на позиция 2 във вектора (може да разчитате, че позициите ще бъдат в обсега на вектора)
б) remove 2 - премахва числото на позиция 2 във вектора (може да разчитате, че позициите ще бъдат в обсега на вектора)
в) shift_left - измествате циклично всички елементи с 1 позиция на ляво като използвате функция и подадете вектора по референция. Примерно, ако числата във вектора са "1, 2, 3", след операцията числата във вектора ще бъдат: "2, 3, 1"
г) reverse - обръща наопаки всички елементи като използвате функция и подадете вектора по референция. Примерно, ако числата във вектора са "1, 2, 3", след операцията числата във вектора ще бъдат: "3, 2, 1". Не може да ползвате готова функция за обръщане на вектор, трябва да имплементирате тази функционалност сами.
д) print - изпечатва текущото състояние на елементите на вектора
е) exit - прекъсва изпълнението на програмата

Комплект 3.

1. Напишете програма, която изчислява щастливо частно на два вектора - A и B. Щастливо частно е: A[0]/B[0] + A[1]/B[1] + A[2]/B[2] + ... + A[n]/B[n]. 
Програмата трябва да чете от стандартния вход едно число N - броя на елементите на векторите. Следват N на на брой числа - тези на първия вектор, след което още N числа - тези на втория.
Реализирайте програмата с функция, която приема 2 вектора и връща double.

Пр. 
Вход:
3
8 25 9
4 5 2
Изход:
11.5

2. Напишете програма, която може да съединява два вектора. Програмата трябва да чете от стандартния вход 1 число N - броя на елементите на първия вектор, следват N на на брой числа - самите елементи. След което още едно число M - броя на елементите на втория вектор, следват M на брой числа - самите елементи. Реализирайте програмата с функция, която приема векторите по референция и не връща стойност. След изпълнението на функцията първия вектор трябва да съдържа неговите елементи и тези на втория вектор.

Пр.
Вход:
3
1 2 3
4
3 1 7 8

Изход:
1 2 3 3 1 7 8

3. Напишете интерактивна програма, която ще манипулира 1 вектор. Тя трябва да прочита от стандартния вход 1 число N - броя на елементите на вектора и N на на брой числа - тези на вектора. 
След което започва да чете и изпълнява операции с прочетения вектор. Програмата трябва да изпълнява следните операции:
a) add 2 -4 - добавя числото -4 на позиция 2 във вектора (може да разчитате, че позициите ще бъдат в обсега на вектора)
б) remove 2 - премахва числото на позиция 2 във вектора (може да разчитате, че позициите ще бъдат в обсега на вектора)
в) shift_left - измествате циклично всички елементи с 1 позиция на ляво като използвате функция и подадете вектора по референция. Примерно, ако числата във вектора са "1, 2, 3", след операцията числата във вектора ще бъдат: "2, 3, 1"
г) reverse - обръща наопаки всички елементи като използвате функция и подадете вектора по референция. Примерно, ако числата във вектора са "1, 2, 3", след операцията числата във вектора ще бъдат: "3, 2, 1". Не може да ползвате готова функция за обръщане на вектор, трябва да имплементирате тази функционалност сами.
д) print - изпечатва текущото състояние на елементите на вектора
е) exit - прекъсва изпълнението на програмата

Комплект 4.

1. Напишете програма, която изчислява щастливо частно на два вектора - A и B. Щастливо частно е: A[0]/B[0] - A[1]/B[1] - A[2]/B[2] - ... - A[n]/B[n]. 
Програмата трябва да чете от стандартния вход едно число N - броя на елементите на векторите и N на на брой числа - тези на първия вектор, след което още N числа - тези на втория.
Реализирайте програмата с функция, която приема 2 вектора и връща double.

Пр. 
Вход:
3
8 25 9
4 5 -2
Изход:
1.5

2. Напишете програма, която може да измества циклично вектор на ляво. Програмата трябва да чете до края на входа елементите на вектора.
Реализирайте програмата с функция, която приема вектора по референция и не връща стойност. След изпълнението на функцията подадения вектор е изместен циклично на ляво: A[0]->A[n-1], A[1]->A[0], ..., A[n-1]->A[n-2].

Пр.
Вход:
1 2 3
Изход:
2 3 1

3. Напишете интерактивна програма, която ще манипулира един вектор. Тя трябва да прочита от стандартния вход 1 число N - броя на елементите на вектора и N на на брой числа - тези на вектора. 
След което започва да чете и изпълнява операции с прочетения вектор. Програмата трябва да изпълнява следните операции:
a) add 2 -4 - добавя числото -4 на позиция 2 във вектора (може да разчитате, че позициите ще бъдат в обсега на вектора)
б) remove 2 - премахва числото на позиция 2 във вектора (може да разчитате, че позициите ще бъдат в обсега на вектора)
в) reverse - обръща наопаки всички елементи като използвате функция и подадете вектора по референция. Примерно, ако числата във вектора са "1, 2, 3", след операцията числата във вектора ще бъдат: "3, 2, 1". Не може да ползвате готова функция за обръщане на вектор, трябва да имплементирате тази функционалност сами.
г) shift_right - измествате циклично всички елементи с 1 позиция на дясно като използвате функция и подадете вектора по референция. Примерно, ако числата във вектора са "1, 2, 3", след операцията числата във вектора ще бъдат: "3, 1, 2"
д) print - изпечатва текущото състояние на елементите на вектора
е) exit - прекъсва изпълнението на програмата